# AOP 주의사항

## 프록시와 내부 호출 문제

<p align="center"><img src="/img/caution/internal.png" width="80%"></p>

스프링은 프록시 방식의 AOP 를 사용하기 때문에, 항상 프록시를 통해서 대상 객체를 호출해야한다.
만약 프록시를 거치지 않고 대상 객체를 직접 호출하게 되면 AOP 가 적용되지 않고, 어드바이스도 호출되지 않는다.
보통 스프링에서 자동으로 프록시 객체가 주입되기에 대상 객체를 직접 호출하는 문제는 일반적이지 않지만,
`대상 객체 내부에서 메서드 호출이 발생`하면 직접 타겟 객체를 호출하는 문제가 발생한다.

- 프록시 방식의 AOP 의 한계

### 대안 1. 자기 자신 주입(CallServiceV1)

<p align="center"><img src="/img/caution/internal_1.png" width="80%"></p>

자기 자신을 주입받기 때문에 순환사이클이 발생하게 된다.

### 대안 2. 지연 조회(CallServiceV2)

스프링 빈을 지연해서 조회하면 되며, `ObjectProvider`, `ApplicationContext`를 사용하면 된다.
- 다만 `ApplicationContext`는 너무 많은 기능을 제공한다
- `ObjectProvider`를 사용하면 객체를 스프링 컨테이너에서 `조회하는 시점을 빈 생성이 아닌 실제 사용시점`으로 지연 가능하다
  - 즉, callServiceProvider.getObject() 호출 시점에 빈을 조회한다

### 대안 3. 구조 변경

<p align="center"><img src="/img/caution/internal_2.png" width="80%"></p>

내부 호출 자체를 없애기 위해, 내부 호출 부분을 다른 클래스로 만들고 외부 호출하는 것으로 구조를 변경한다.
하지만, 상황에 따라 분리가 아닌 다른 방법 또한 존재한다. 예를 들어 클라이언트에서 external 과 internal 을 각각 호출할
수 도있다.

## 프록시 기술과 한계 - JDK 동적 프록시

### 타입 캐스팅

JDK 동적 프록시와 CGLIB 을 사용한 AOP 프록시를 만드는 방법은 다음과 같다
- JDK 동적 프록시 : 인터페이스 필수, 인터페이스를 기반 프록시 생성
- CGLIB : 구체클래스를 기반으로 프록시 생성

따라서, 인터페이스가 있는 경우에는 JDK 동적 프록시와 CGLIB 중에 하나를 선택해서 프록시를 생성할 수 있다.
- proxyTargetClass
  - false : JDK 동적 프록시를 사용해서 인터페이스 기반 프록시 생성
  - true : CGLIB 을 사용해서 구체 클래스 기반 프록시 생성
- JDK 동적 프록시의 한계
  - JDK 동적 프록시를 통해 만들어진 프록시는 구체 클래스로 타입캐스팅이 불가능하다
  - CGLIB 의 경우 구체 클래스 기반으로 만들기에, 부모인 인터페이스 타입으로도 캐스팅이 가능하다
  - 하지만 JDK 는 애초에 인터페이스 기반으로 만들어지기에, 자식 클래스 타입으로는 캐스팅이 불가능하다

타입 캐스팅을 할 일이 일반적으로는 없어보이지만, 문제는 `의존관계 주입시 발생`한다.

### 의존관계 주입

<p align="center"><img src="/img/caution/DI.png" width="80%"></p>

JDK 동적 프록시를 사용하면 의존관계 주입 시 문제가 발생한다

## 프록시 기술과 한계 - CGLIB

### 대상 클래스에 기본 생성자 필수

CGLIB 는 구체 클래스를 상속받아서 만들기 때문에, 자식클래스의 생성자를 호출할 때 부모 클래스의 생성자도 호출해야 한다.
따라서, 기본생성자가 필수이며 CGLIB 생성자는 대상 클래스의 기본 생성자를 호출한다.

### 생성자 2번 호출

<p align="center"><img src="/img/caution/cglib.png" width="80%"></p>

1. 실제 target 의 객체 생성 시
2. 프록시 객체를 생성할 때, 부모 클래스의 생성자 호출

### final 키워드 클래스, 메서드에서 사용 불가

final 키워드가 클래스에 있으면 상속이 불가능하고, 메서드에 있으면 오버라이딩이 불가능하다

## 스프링의 해결책

- 스프링 3.2
  - CGLIB 를 스프링 내부에 함께 패키징
  - 라이브러리 추가없이 CGLIB 사용
- 스프링 4.0
  - 기본 생성자 필수 문제 해결
    - `objenesis` 라이브러리를 사용해서 기본 생성자 없이 객체 생성이 가능하다
    - 생성자 호출 없이 객체를 생성할 수 있는 라이브러리
  - 생성자 2번 호출 문제 해결
    - 이 또한 `objenesis` 라이브러리를 통해 해결
- 스프링 부트 2.0
  - CGLIB 기본 사용으로 적용
  - 따라서, 구체 클래스 타입으로 의존관계를 주입하는 문제를 해결